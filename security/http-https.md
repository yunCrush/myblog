# Http/Https

### 1.Http请求/响应报文

　请求报文：请求行(GET /index.html Http/1.0)---请求头部("Content-Type":"application/json")---**换行符**--请求体

　响应报文：状态行（HTTP/1.0 403 ForBidden）--响应首部（"Content-Type":"application/json"）--**换行符**--响应体

<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-Lu8htiKy_jajPwKJcN9%2Fuploads%2Fgit-blob-f89ba60f8ba8aea29bf0f1ab066b305604de356a%2Fimage%20(37).png?alt=media" alt=""><figcaption></figcaption></figure>

### 2.Http2新特性

http2.0的四个概念

Connection：1 个 TCP 连接，包含 1 个或者多个 stream。所有通信都在一 个 TCP 连接上完成

Stream：一个双向通信的数据流，包含 1 条或者多条 Message，每个流有一个标志符，防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具 有偶数ID

Message：指逻辑上的HTTP消息（请求/响应）。一系列数据帧组成 了一个完整的消息。比如一系列DATA帧和一个HEADERS帧组成了请求消 息

Frame：最小通信单位，以二进制压缩格式存放内容。来自不同数据流的 帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装

*   1.二进制分帧Frame

    在不改动http的方法语义和状态的情况下，致力于突破上一代标准的性能 限制，改进传输性能，实现低延迟和高吞吐量 ， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并 对它们采用二进制格式的编码。http2.0的性能的关键在于低延迟而不是高带宽。延迟是指从发送请求到接收到第一个字节的时间。它取决于网络中的各种因素，如传输距离、路由器和交换机的延迟、网络拥塞等。较低的延迟意味着请求能够更快地到达服务器并获取响应，从而减少了用户等待的时间。

    HTTP 2.0 通过让所有数据流共用同一个TCP连接，让高带宽也能真正的服务于HTTP的性能提升。

    单连接的好处：

    减少服务连接压力，连接吞吐量就增大了；TCP连接减少网络设备就能及时的处理传入传出的数据包，使得网络拥塞的状况得以改观，TCP少的话，网络设备就不需要花费那么多的处理能力来管理TCP的连接；慢启动时间减少,拥塞和丢包恢复速度更快



    <figure><img src="https://cdn.jsdelivr.net/gh/yunCrush/yc-image/image/http2-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7.png" alt=""><figcaption></figcaption></figure>
*   2.头部压缩HPACK

    正常的http请求体会经过gzip压缩，头部压缩很好理解，在支持http2.0的浏览器和服务端同时维护一张静态表和动态表，静态表是常见的头部名称与值，如果遇到不在静态表中的值，就会用到动态表，每个动态表只针对一个连接（TCP），每个连接的压缩解压缩的上下文有 且仅有一个动态表，动态表中没有的index则添加到动态表中，第二次就可以直接传输index了。

    静态表：

    index Header name Header value

    1         :authority

    2         :method          GET

    这样通过传一个index:2 来表达用的是GET方法
*   3.多路复用Multiplexing

    http2连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时， 再根据不同帧首部的流标识符重新连接将不同的数据流进行组装



    <figure><img src="https://cdn.jsdelivr.net/gh/yunCrush/yc-image/image/http2-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt=""><figcaption></figcaption></figure>
*   4.服务器推送Server Push

    服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客 户端明确地请求，因为没有建立连接，发送请求过程，所以静态资源通过服务端推送的方式 可以极大地提升速度

### 3.Https

HTTPS是身披SSL/TLS外壳的HTTP，HTTPS和HTTP协议相比提供了

* 1.数据完整性：内容传输经过完整性校验
* 2.数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥
* 3.身份认证：第三方无法伪造服务端（客户端）身份

数据完整性和隐私性由TLS Record Protocol保证，身份认证由TLS Handshaking Protocols实现。

#### **对称加密**

AES（Advanced Encryption Standard）：高级加密标准，是现 在公认的最安全的加密方式，是对称密钥加密中最流行的算法。 AES128和AES256主要区别是密钥长度不同（分别是128bits,256bits)、加 密处理轮数不同（分别是10轮，14轮），后者强度高于前者 。堆成加密使用的是同一个秘钥进行加密解密，如果被劫持，就会被破解密文。

#### **非对称加密**

保证了数据不会被破解，需要两个秘钥：公钥和私钥。公钥加密--私钥解密、私钥加密--公钥解密。

常用算法：RSA、DSA、ECDSA

因为公钥是暴露的，所以如果是用私钥加密发送的数据，可能被黑客解密。

#### **对称与非对称加密**

一开始，公钥与私钥都存储在服务端，关键点在于，公钥加密的数据只能私钥解密，私钥是不可能泄露的，所以客户端通过公钥加密了一个随机数，只有服务端的私钥能解密，这样这个随机数就只有客户端和服务端知道，不会被泄露，后续基于这个随机数采取堆成加密即可，对称加密速度更快。

<figure><img src="https://cdn.jsdelivr.net/gh/yunCrush/yc-image/image/https-%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png" alt=""><figcaption></figcaption></figure>

但是可能存在报文可能被篡改问题和通信方身份被伪造的情况。黑客伪造成服务端，返回给了黑客的公钥，而不是服务端的公钥，而黑客也是有自己的私钥的，所以就冒充服务端与客户端进行通信了。因此推出了数字签名与数字证书解决这两个问题。

<figure><img src="https://cdn.jsdelivr.net/gh/yunCrush/yc-image/image/https-%E4%BC%AA%E9%80%A0%E6%9C%8D%E5%8A%A1%E7%AB%AF.png" alt=""><figcaption></figcaption></figure>

#### **数字签名**

有两种功能：能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名 ；确定消息的完整性,证明数据是否未被篡改过 。

我们需要确定的是与自己通信的另一方的身份，这里可以将我们需要发送的消息data，通过hash算法计算得到摘要，然后通过服务器的私钥进行加密得到密文X，这个密文X称为数字签名，并且与data原文一起发送给服务端，这样服务端对密文X使用客户端的公钥进行解密就得到了摘要A1，同样的我们对原文data采用hash算法计算得到摘要A2，判断A1与A2是否一致，这样就可以判断消息来源的身份。同样的服务器可以像这样将数字签名和原文发送给客户端。

上述过程的关键是我们需要知道服务端的公钥，并且保证是服务端的。所以引入了证书，证书是由权威的机构颁发。

#### **证书**

证书包含服务器的公钥，以及证书的有效期，相关申请者的一些信息等。证书颁发机构称为CA，CA的数量并不多，因此集成在了浏览器内部与操作系统内，证书一般是很难伪造的。

这里由网站的运营人员进行证书的申请，客户端在向服务器建立连接的时候，服务端就会返回一个证书给到客户端，其中就包括了服务器的公钥，关键点就在这里，如何确保这个证书就是真的呢？不是被黑客劫持的呢？客户端同样读取证书中的相关明文信息，采用相同的hash函数进行计算得到摘要A3，因为浏览器内部集成了CA的公钥，我们就可以遍历浏览器内部的几个公钥，对数字签名进行解密，得到摘要A4，比较A3与A4是否相同，这样就可以验证了这个证书的合法性，是由CA机构颁发的，所以里面的服务器的公钥就可以进行合法的使用。

整个验证证书合法性的关键点在于，浏览器内置了CA机构的公钥，CA机构给服务器的证书是CA的私钥加密的，这一点是黑客无法破解的。

上图被黑客伪造成服务器的关键点就是客户端并没有验证返回的公钥是否是合法的，所以只需要对上图的第二步中收到响应进行校验即可，如下：

<figure><img src="https://cdn.jsdelivr.net/gh/yunCrush/yc-image/image/https-%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1.png" alt=""><figcaption></figcaption></figure>

#### **个人疑问**

会不会存在某种情况黑客伪造的证书，恰好能够被CA的公钥进行解密呢？

来自chatgpt的答案：生成一个合适的私钥和对应的公钥是非常复杂的过程，需要大量的随机性，以及强大的加密算法来保障其安全性，基本是不可能事件。

### TCP三次握手

<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-Lu8htiKy_jajPwKJcN9%2Fuploads%2Fgit-blob-72fdfadc44bb3cb7b1c671cecc643c7b439c0b84%2Fimage%20(40).png?alt=media" alt=""><figcaption></figcaption></figure>

为什么TCP客户端最后还要发送一次确认呢？

　由于请求在网络中滞留，在其后面的请求完成了连接，进行数据传输，关闭连接。此时滞留的请求才到达，如果是两次握手，则又建立了连接，但是却并无数据发送，会导致资源的浪费。如果是三次握手，即使服务端响应请求，但是客户端并不会再发送一次确认报文，所以并不会创建连接。

为什么三次握手？

　第一次握手：保证了客户端的发送能力和服务端的接收能力。

　第二次握手：保证了服务端的发送能力与客户端的接收能力，即客户端知道服务端的接收发送能力都正常。

　第三次握手：服务端第二次发送报文后，并不知道客户端的接收能力，所以需要第三次握手，保证客户端服务端都明白双方的接收发送能力都正常。

SYN flood攻击：伪造大量的ip,发送请求给服务器，服务器会进行响应，但是由于客户端的Ip是伪造的，并不会响应，此时服务器并不知道，仍然会进行3-5次的重试，大量的虚假Ip请求会造成服务端消耗大量的连接做SYN+ACK来处理这种半连接，最后的结果是服务器无暇理睬正常的连接请求，导致拒绝服务。

### TCP四次挥手

<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-Lu8htiKy_jajPwKJcN9%2Fuploads%2Fgit-blob-b9a83d0df33d1930b6dafa2f79f4e9afaec669c2%2Fimage%20(42).png?alt=media" alt=""><figcaption></figcaption></figure>

为什么客户端最后还要等待2MSL？

　去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。这恰恰 就是2MSL( Maximum Segment Life)。

在这2MSL时间内，如果客户端再次收到来自服务端的Fin请求，则会重启2MSL计时器。

客户端发送的ACK可能存在丢失，如果丢失，服务端并不知道自己发出的Fin请求，客户端是否收到，所以可能会再次发送Fin请求。

2MSL是为了保证在客户端释放TCP占用的端口时，不会又和服务端的端口建立连接，使得网络中的网络中的新老报文发送冲突，需要等待网络中的报文全部消失。

如果已经建立了连接，但是客户端突然出现故障了怎么办？

　TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下 去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时 器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器 就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文 仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

\
