---
description: 介绍进程与线程的相关知识
---

# OS线程与进程（二）

## 进程与线程

**进程 正在执行的应用程序的副本，进程是资源分配的基本单位，线程是轻量级进程，是程序执行的基本单位。**操作系统调度线程。

分时和调度：每个进程在执行时会获得操作系统分配的一个时间片，执行完后，轮到下一个进程（线程），现代操作系统都是直接调度线程，不会调度进程。

分时技术：轮流交替执行。

进程与线程切换：

![进程、线程切换流程图](<../../.gitbook/assets/image (16).png>)

现代操作系统都是切换线程。一个进程（线程）被选择执行后，它会继续完成之前被中断时的任务，这需要操作系统来执行一小段底层的程序帮助进程（线程）恢复状态。线程3种基本状态：就绪->运行->阻塞。fork来创建克隆一个和原状态一样的进程。

**提问** :**进程的开销比线程大在了哪里？**

　 　****　 　Linux中创建一个进程会自动创建一个线程，也就是主线程，创建一个进程伴随着，需要划分一片独立的内存空间，以及一大堆的初始化工作，如内存区域的分段（堆，栈，正文区等）。相反，创建线程则简单了许多，只需要指定PC指针和寄存器的值，并且给线程分配一个栈用来执行程序，同一个进程的多个线程可以复用堆栈，因此创建进程比创建线程慢，而且进程的内存开销更大。

## **锁、信号量、分布式锁**

原子操作：不可分割，执行过程不可中断。

竞争条件：多个线程对同一个资源（内存地址）的读写存在竞争，最后资源的值不可预测。

临界区：共享资源的程序片段。

解决竞争条件：1.互斥，不让程序同时进入临界区；2.避免临界区，本地独享变量（并非所有情况合适）3.CAS（compare and Swap）指令，明确知道内存地址中的值，如果内存中的值与知道的值不一致，失败。

```
cas(&oldValue, expectedValue, targetValue)

# i++操作分为3步，读取i,计算i+1,写回值

# 将内存变量i的值由100更改为101
cas(&i,100,101)
cas(&i,i,i+1)

# 多次读取，&i实时读取，如果 cas 返回 false，那么会尝试再读一次 i 的值，直到 cas 成功
# 自旋锁例子
while(!cas(&i, i, i+1)){

  // 什么都不做

}
```

tas指令与CAS相似

```
# tas 指令的目标是设置一个内存地址的值为 1，它的工作原理和 cas 相似。
# 首先比较内存地址的数据和 1 的值，如果内存地址是 0，那么把这个地址置 1。如果是 1，那么失败
tas(&lock) {
  return cas(&lock, 0, 1)
}

```

**自旋锁**   CPU一直执行获取锁的指令，直到其它线程释放锁，而自己不会主动释放资源，优点：不会发生线程切换，线程切换会消耗大量时间，缺点，消耗CPU资源，拿不到锁，一直执行。

wait 生产者消费者模型，wait将当前线程挂到等待队列，notify作为消费者

synchronized 关键字的内部实现，用到了封装好的底层代码——Monitor 对象

信号量 ：允许多个线程进入临界区。

死锁：1.资源互斥条件；2.请求与保持；3.不可剥夺；4.循环等待

　**分布式锁** 程序在多台服务器执行，解决竞争条件，实现锁，需要原子操作。

Redis 的 setnx 指令，Zookeeper 的节点操作。

**提问:** 如何在同一时间只有两个线程允许？

采用信号量，同时控制两个线程进入临界区,另一种方式采用生产者、消费者模型，想要进入的先进入等待队列等待，然后每次消费两个线程，类似于线程池，所以考虑实现一个ThreadPool，然后实现一个调度器类，最后实现一个调度2个线程的调度算法。

## 乐观锁、悲观锁

并发场景，是为了对数据的理解达到同步一致，同步的一种方法式临界区互斥，即每次只允许一个线程进入临界区。让临界区互斥的办法是给临界区上锁，具有强烈的排他性，对修改持保守态度，称为**悲观锁（每一次读取数据，以为别人会修改，上锁），**如mysql的行锁，表锁，synchronized，ReentrantLock悲观锁思想。

乐观锁：基于版本控制的场景，如git，每一次拿取，以为别人不会修改，所以不会上锁，但是在提交时会判断这期间有没有人修改。通过版本号机制，或者CAS算法来实现。

## 线程的调度

先来先服务，短作业优先、 优先级队列、抢占（时间片划分）

平均等待时间 = 总等待时间/任务数

多级队列模型：从下往上，优先级提高，分为多级

**提问：线程调度都有哪些方法？**

答：非抢占式的先来先服务算法是最朴素的，保证了公平性与吞吐量，但是我们需要考虑到用户的平均等待时间，所以操作系统往往都实现抢占。操作系统实现抢占，仍然希望有优先级，仍然希望有最短作业优先，但是因为操作系统无法预估每个线程的执行时间，所以用到分级队列。最高优先级的考虑非抢占的优先级队列，其他任务放到分级队列中执行，从最高优先级时间片最小向最低优先级时间片段最大逐渐沉淀，这样保证了小任务和优先级高的最先执行。

## 进程间通信

进程间通信（Intermediate Process Communication，IPC）**，**系统创建的进程们之间在交换数据。

**远程调用** 客户端将本地的方法调用（后面跟一个服务程序：stub）封装成一个请求，发送给服务器端，服务端将请求转化为一个真是的方法调用，执行服务端的方法，返回结果给客户端作为函数的返回值。

![客户端服务端通信](<../../.gitbook/assets/image (17).png>)

RPC 调用过程有很多约定， 比如函数参数格式、返回结果格式、异常如何处理。还有很多细粒度的问题，比如处理 TCP 粘包、处理网络异常、I/O 模式选型。常见RPC框架：gRPC,thrift,dubbo。

**RPC 真正的缺陷是增加了系统间的耦合。当系统主动调用另一个系统的方法时，就意味着在增加两个系统的耦合。长期增加 RPC 调用，会让系统的边界逐渐腐化。**事件不会增加耦合，可用消息队列实现，可了解DDD架构。

**提问：进程间的通信方式有哪些？**

单机模型

1. 管道---命名管道。
2. 本地内存共享，linux中有POSIX共享内存库--shmem，以虚拟文件系统的方式，从内存中划分一块内存，供两个进程使用，看上去是打开的文件，直接操作的是内存。（速度快，但是程序不好实现，要考虑并发控制与同步问题）。
3. 本地消息队列，分为两种常见的方法，a.消息队列，现代操作系统都有提供，b.直接用网络请求，TCP/IP协议。（发布-订阅模式实现）

分布式模型

1. RPC；2.消息队列（最好）；3.网络请求

**内存一致性模型：**多个线程在同一时刻，对某个内存地址中的数据认知是否一致。

检查磁盘坏道：sudo badblocks -v /dev/sda5（df查看得知挂载）

