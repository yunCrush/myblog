---
description: 操作系统的概述问题
---

# OS概述（一）

**提问**: **“ Linux 内核和 Windows 内核有什么区别**？

内核：应用连接硬件设备的桥梁。至少具备以下4种能力：管理进程，线程，管理内存（决定内存用来做什么），连接硬件设备（为进程、和设备间提供通信能力），提供系统调用（接收进程发送来的系统调用）

Linux 是宏内核架构，宏内核的特点就是有很多程序会打包在内核中，比如，文件系统、驱动、内存管理等。**微内核，内核只保留最基本的能力。比如进程调度、虚拟内存、中断。多数应用，甚至包括驱动程序、文件系统，是在用户空间管理的**。

对于微内核设计，驱动在内核外，驱动和硬件设备交互就需要频繁做内核态的切换。

Windows 有两个内核，最新的是 NT 内核，目前主流的 Windows 产品都是 NT 内核。NT 内核和 Linux 内核非常相似，没有太大的结构化差异。

从整体设计上来看，Linux 是宏内核，NT 内核属于混合型内核。和微内核不同，宏内核和混合类型内核从实现上来看是一个完整的程序。只不过混合类型内核内部也抽象出了微内核的概念，从内核内部看混合型内核的架构更像微内核。

另外 NT 内核和 Linux 内核还存在着许多其他的差异，比如：

*
  1. Linux 内核是一个开源的内核；
  2. 它们支持的可执行文件格式不同；（ELF与PE）可执行文件链接格式 Portable Executable
  3. 它们用到的虚拟化技术不同

**提问** ：**用户态线程和内核态线程有什么区别**？

很多操作系统，将内存分成了两个区域：内核空间（Kernal Space），这个空间只有内核程序可以访问；用户空间（User Space），这部分内存专门给应用程序使用，独立不会被操作系统发现。

用户态执行系统调用要切换到内核态

![用户态切换到内核态流程](<../../.gitbook/assets/image (15) (1).png>)

用户态线程创建成本低，问题明显（有进程的主线程调动，一旦发生阻塞会交出CPU的执行权），不可以利用多核。内核态线程，创建成本高，可以利用多核，操作系统级别优化（线程阻塞可以切换），切换速度慢

**映射关系**

用户态线程--------->内核态线程

1. 多对一，少见。
2. 一对一，利用多核优势，每个用户态都需要通过系统调用创建一个绑定的内核线程，并附加在上面执行。 这种模型允许所有线程并发执行，能够充分利用多核优势，Windows NT 内核采取的就是这种模型。
3. 多对多，这种模式下会为 n 个用户态线程分配 m 个内核态线程。m 通常可以小于 n。一种可行的策略是将 m 设置为核数。这种多对多的关系，减少了内核线程，同时也保证了多核心并发。Linux 目前采用的就是该模型。

**中断** : CPU 要中断当前执行的程序，将 PC 指针跳转到一个固定的位置

CPU 需要知道 PC 指针该跳转到哪个地址，这个地址，称为中断向量（Interupt Vector）。需要把不同的中断类型进行分类，这个类型叫作中断识别码

断可以由 CPU 指令直接触发，这种主动触发的中断，叫作同步中断。
