---
description: 这里介绍JVM内存区域的知识点与类加载机制。
---

# JVM内存结构与类加载

　　JVM\(Java Virtual Model\)Java虚拟机模型与JMM\(Java Memory Model\)不同。

## １.JVM组件

　　JVM的主要组成部分包括：**类加载引擎，运行时数据区，执行引擎，本地库接口**。JVM结构图如下所示：

![JVM&#x7ED3;&#x6784;&#x56FE;](../.gitbook/assets/image%20%2827%29.png)

　　**组件的作用：** 首先通过**类加载引擎**将JAVA代码转换成字节码，然后**运行时数据区**会将字节码加载到内存中，由于字节码只是JVM的一套规范指令集，并不能直接交给底层操作系统执行执行，这里需要特定的命令解析器**执行引擎**来解析，在解析的过程会调用其他语言的**本地库接口**来实现整个程序的功能。



## ２.JVM运行时数据区

从线程的共享与私有角度分类

**私有**：Java虚拟机栈，本地方法栈，程序计数器

**共享**：堆，方法区

1. **程序计数器：**作用是保存当前正在执行的 JVM 指令地址。，字节码解析器的工作主要是通过改变这个计数器的值，来读取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基本功能，都需要依赖这个计数器。
2. **本地方法栈：**与虚拟机栈的作用是一样的，只不过虚拟机栈是服务JAVA方法的，而本地方法栈是服务虚拟机调用本地Native方法的。
3. **Java虚拟机栈：**用于存储局部变量表，操作数栈，动态链接，方法出口信息等。
4. **堆：** Java虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例以及数组都在这里分配内存。
5. **方法区：**用于存储已经被虚拟机加载的类的信息，运行时常量池，静态变量，即时编译后的代码等数据。

## ３.类加载器

　　**对于任意一个类，都需要有加载它的类加载器和这个类本身在一同确立在JVM中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将class文件加载到JVM内存里面，然后再转换为class对象。**

**分类**

1. **启动类加载器** 虚拟机自身的一部分，用来加载JAVA\_HOME/jre/lib目录中的，或者被-Xbootclasspath参数所指定的路径中并且被虚拟机识别的类库。
2. **其它类加载器**

   a. 扩展类加载器\(Extension ClassLoader\)：负责加载JAVA\_HOME／jre/lib／ext目录或java.ext.dirs系统变量指定的路径中的所有的类库。

   b.应用程序类加载器\(Apllication ClassLoader\)： 负责加载用户类路径\(classpath\)上的指定类库，我们可以直接使用这个类加载器。一般而言，我们没有自定义类加载器默认就使用这加载器。

　　**除了以上三种，我们还可以通过集成Java.lang.ClassLoader实现自定义的类加载器。**

## ４.双亲委派模型

　　如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类去完成，每一层的类加载都是如此，这样所有的请求都会被传送到顶层的**启动类加载器**中，只有当父加载无法完成加载请求\(它的搜索范围中没有找到所需要的类\)时，子加载器才会尝试去加载。如下图所示：

![&#x53CC;&#x4EB2;&#x59D4;&#x6D3E;&#x6A21;&#x578B;](../.gitbook/assets/image%20%2819%29.png)



## 5.类加载的执行过程

1. 加载

   　　指JVM读取Class文件，并且根据Class文件在堆上创建对象的过程，这里读取Class文件时，可以是文件形式，也可以是Jar包，war包等。

2. 验证

   　　检查Class文件是否符合当前虚拟机的要求，保障虚拟机自身的安全。

3. 准备

   　　给类中的静态变量分配存储空间。

4. 解析

   　　JVM会将常量池中的符号引用替换为直接引用。符号引用理解为一个标识，而直接引用直接指向内存中的地址。

5. 初始化

   　　对静态变量和静态代码块进行初始化工作。

