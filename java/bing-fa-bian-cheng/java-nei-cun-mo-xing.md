---
description: JVM 内存结构和 Java 虚拟机的运行时区域有关，Java 内存模型和 Java 的并发编程有关。
---

# Java内存模型

JMM(Java Memory Model)是和多线程相关的**一组规范**，需要各个 JVM 的实现来遵守 JMM 规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。这样一来，即便同一个程序在不同的虚拟机上运行，得到的程序结果也是一致的。JMM中最重要的三部分：重排序，原子性，内存可见性。

## 1.重排序

编译器、JVM 或者 CPU 都有可能出于优化等目的，对于实际指令执行的顺序进行调整，这就是\*\*重排序。\*\*但是重排序并不意味着乱排序

```
// 重排序前
a = 1;
b = 2;
a = a + 1;

// 重排序后，查看反编译后的代码可以减少load a 与store a
a = 1;
a = a +1;
b = 2;
```

好处:提高处理速度，

重排序的三种情况：

1. 编译器优化：JVM、JIT编译器通过乱序执行的技术，将相同的数据操作放到一起，避免重读。
2. CPU重排序：与编译器优化类似。
3. 内存的“重排序“：并不存在真正的重排，由于内存内有缓存的存在，在 JMM 里表现为主存和本地内存，而主存和本地内存的内容可能不一致，所以这也会导致程序表现出乱序的行为。

## 2.原子性

原子操作，典型的"i++"分为三个步骤：1.读取；2.增加；3.保存,这就不是原子操作，容易发生线程不安全问题。

Java中的原子操作：

1. 除了long，double的基本类型
2. 所有reference引用的读写操作
3. 加了volatile所有变量的读写操作
4. java.concurrent.Atomic 包中的一部分类的一部分方法是具备原子性的，比如 AtomicInteger 的 incrementAndGet 方法。

## 3.内存可见性

一个A线程对变量进行修改，但是另一个B线程没有及时的同步到，相当于A的修改对线程B不可见。

由于CPU的多级缓存，导致线程间对于共享变量存在可见性问题

\*\*保证可见性的措施：\*\*Synchronized（既保证可见性，又保证原子性）、Lock、volatile关键字。

![](<../../.gitbook/assets/image (17).png>)

每个线程只能够直接接触到工作内存，工作内存独立不共享，主内存由多个线程共享，线程无法直接操作主内存，而工作内存中所保存的正是主内存的共享变量的副本，主内存和工作内存之间的通信是由 JMM 控制的。

## 4.Happens-before关系

如果第一个操作 happens-before 第二个操作，那么我们就说第一个操作对于第二个操作一定是可见的，也就是第二个操作在执行时就一定能保证看见第一个操作执行的结果。

满足Happens-before规则：

**1.单线程规则；2.锁操作规则**（ **synchronized 和 Lock 接口等**）：如果操作 A 是解锁，而操作 B 是对同一个锁的加锁，那么 hb(A, B) **；** \*\*3.volatile 变量规则；4.线程启动规则：\*\*Thread 对象的 start 方法 happen-before 此线程 run 方法中的每一个操作。**5.线程join规则：**

![线程join规则](<../../.gitbook/assets/image (40).png>)

\*\*6.中断规则:\*\*一个线程被其它线程Interrupt时，检测中断时，一定能够检测此次中断的发生 。

**7.** **并发工具类的规则**: 线程安全的并发容器（HashTable）,存入操作Happens-before读取操作；信号量（Semaphore）释放许可证的操作 happens-before 获取许可证的操作；Future 任务中的所有操作 happens-before Future 的 get 操作；线程池，提交任务的操作 happens-before 任务的执行。
