# 概念

## 1. 请求/响应报文

　请求报文：请求行(GET /index.html Http/1.0)---请求头部("Content-Type":"application/json")---**换行符**--请求体

　响应报文：状态行（HTTP/1.0 403 ForBidden）--响应首部（↑）--**换行符**--响应体

![Http vs Https](<../../.gitbook/assets/image (42).png>)

## 2. 三次握手

![三次握手](<../../.gitbook/assets/image (4).png>)

1. 为什么TCP客户端最后还要发送一次确认呢？

　由于请求在网络中滞留，在其后面的请求完成了连接，进行数据传输，关闭连接。此时滞留的请求才到达，如果是两次握手，则又建立了连接，但是却并无数据发送，会导致资源的浪费。如果是三次握手，即使服务端响应请求，但是客户端并不会再发送一次确认报文，所以并不会创建连接。

2\. 为什么三次握手？

　第一次握手：保证了客户端的发送能力和服务端的接收能力。

　第二次握手：保证了服务端的发送能力与客户端的接收能力，即客户端知道服务端的接收发送能力都正常。

　第三次握手：服务端第二次发送报文后，并不知道客户端的接收能力，所以需要第三次握手，保证客户端服务端都明白双方的接收发送能力都正常。

**SYN flood攻击**：伪造大量的ip,发送请求给服务器，服务器会进行响应，但是由于客户端的Ip是伪造的，并不会响应，此时服务器并不知道，仍然会进行3-5次的重试，大量的虚假Ip请求会造成服务端消耗大量的连接做SYN+ACK来处理这种半连接，最后的结果是服务器无暇理睬正常的连接请求，导致拒绝服务。

## 3. 四次挥手

![四次挥手](<../../.gitbook/assets/image (52).png>)

**为什么客户端最后还要等待2MSL？**

　去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。这恰恰 就是**2MSL( Maximum Segment Life)**。

在这2MSL时间内，如果客户端再次收到来自服务端的Fin请求，则会重启2MSL计时器。

1. 客户端发送的ACK可能存在丢失，如果丢失，服务端并不知道自己发出的Fin请求，客户端是否收到，所以可能会再次发送Fin请求。
2. 2MSL是为了保证在客户端释放TCP占用的端口时，不会又和服务端的端口建立连接，使得网络中的网络中的新老报文发送冲突，需要等待网络中的报文全部消失。

**如果已经建立了连接，但是客户端突然出现故障了怎么办？**

　TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下 去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时 器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器 就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文 仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
