# 分布式事务

### 分布式事务理论

**Base理论**

1.  Basically Available（基本可用）

    允许损失部分可用性，但核心功能可用
2.  Soft State（软状态）

    允许系统存在中间状态，而该中间状态不会影响系统整体可用性
3.  Eventual Consistency（最终一致性）

    系统中的所有数据副本经过一定时间后，最终能够达到一致的状态

在分布式网络中，分区容错性是一定会存在的，Base理论是对一致性与可用性的权衡的指导

**Cap理论**

1. Consistent一致性：所以节点的数据时刻保持一致。锁定事务资源
2. Availability可用性：任何情况都能够处理客户端的请求。尽最大努力提供服务
3. Partition-Tolerance分区容错性：发生网络分区时，系统应该持续提供服务。

### 分布式事务解决方案

![image-20230923012409475](https://cdn.jsdelivr.net/gh/yunCrush/yc-image/image/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%A6%82%E8%A7%88.png)

#### 2PC

基于协调者的强一致性，大多数关系型数据库所支持的XA协议都属于两阶段提交。

角色：事务协调器，参与者

第一阶段： 事务协调器开启全局事务，发起prepare到,参与者开始锁定资源，并返回ack告知事务协调器是否可以进行事务提交，事务协调器根据返回的结果来决定是commit/rollback。

第二阶段： 再次发送commit/rollback请求给参与者，参与者进行本地事务资源的释放。最后事务协调器对全局事务进行提交。

![image-20230923005501733](https://cdn.jsdelivr.net/gh/yunCrush/yc-image/image/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-2PC.png)

优点：容易理解，原理简单。 缺点：需要等待ACK返回后才可执行第二阶段，同步阻塞。数据不一致，如果第二阶段发生了网络异常导致部分参与者未收到Commit，部分参与者收到，导致了数据最终的不一致 单点问题和脑裂：过于依赖协调者，若协调者挂了，整个集群将不可用 集群中出现多个协调者时，无法保证二阶段提交协议的正确性。

空回滚与防悬挂 空回滚：发生在第一阶段，网络丢包，prepare请求丢失，网络恢复后，根据协调者的超时规则，会在超时后发送Rollback给参与者，导致了参与者之前并没有参与本地事务开启，却需要关闭本地事务，释放资源。解决办法，在第一阶段记录XID,关闭本地事务时判断是否有XID。

```
//第一阶段
insert <prepare.xid> into roll-back.log
//第二阶段
if (commit.xid not in roll-back.log) {
	return
}

```

防悬挂：（建立在允许空回滚的基础上）第一阶段发送prepare到参与者，参与者响应超时，事务协调者发送rollback，再次受到了之前由于网络延迟的prepare请求。很难判断这个prepare是上次的，还是一个新的事物的prepare请求。可以在第二阶段写入XID

```
// 第二阶段
insert <rollback.xid> into roll-back.log
if (rollback.xid not in rollback.log) {
	return
}
// 第一阶段
if (prepare.xid in rollback.log) {
	// 表明是上次的prepare
	return 
}

```

#### 3PC

三阶段协议：询问阶段-预提交阶段-提交阶段 将锁定资源滞后，降低事务资源锁定的范围，若在集群中存在某个别不具备处理事务能力的参与者，则可以提前中断事务，而不是像二阶段提交上来锁定资源。 为了解决同步阻塞问题，三阶段协议增加了超时机制，解决了协调者宕机后参与者无法释放资源的问题。

![image-20230923010743478](https://cdn.jsdelivr.net/gh/yunCrush/yc-image/image/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-3PC.png)

阶段一：CanCommit 参与者健康自检，判断与协调者的连接，判断是否能执行本次事务，是否和其他事务存在冲突，返回信息给协调者。 阶段二：PreCommit 若收到来自参与者的No，则会向所有参与者发送Abort请求进行中断，因为参与者没有进行资源的锁定，参与者只需要更新分支事务的状态即可。

若收到的是参与者的Yes,则协调者发起PreCommit请求，参与者将自己的状态更新为预提交，然后锁定事务资源，尝试执行逻辑，记录Undo与Redo信息。然后再返回给协调者分支事务的状态。

阶段三：DoCommit 如果在超时时间内收到参与者的No，或者是超时没有响应，则向参与者发送Abort请求，回滚分支事务，参与者反馈分支事务结果，协调者将结果反馈给客户端。

如果收到的是yes，则执行提交事务请求。这里需要注意，经历了前面两个阶段，并且收到了yes，参与者会认为全局事务是值得提交的，在提交阶段，如果参与者未收到协调者的commit请求，则自动提交了。（这里有一点注意，如果部分参与者返回的是yes,部分返回的是no，同时又没有收到阶段三的请求，会导致数据不一致） 优点：增加了超时机制和自动提交/中断功能在第三阶段时，参与者等待协调者的请求超时，参与者可以自行决定rollback或者是commit

会排除掉个别不具备处理事务能力的参与者，再进行资源的锁定。

缺点：增加了一个阶段，等于增加了复杂度，同时多增加的RPC交互也会降低整个协议的协商效率。第三阶段由于网络异常导致的丢包，没有给参与者发送请求，所以参与者会根据自身情况决定rollback或者是commit，导致了最终的数据不一致性。

